---
title: "week 1: printf statements and UART"
layout: post
date: 2019-12-10 12:00
image: /assets/images/markdown.jpg
headerImage: false
tag:
- stm32
- printf
- uart
- MCU
category: blog
author: ayoubsabri
description:
---

During the development of the firmware of an embedded system, we often need to send debug messages to verify the behaviour of the system. There are several ways to do this; the main ones are:

- [semihosting][sh]: easy to use but very slow (needs a gdb server)
- [ITM][itm]: the fastest way but not available on all processors' cores (Cortex-M3 and +)
- [UART][uart]: the most employed and reliable (over a RS-232 hardware connection)

In this tutorial, our goal is to be able to send debug messages with a microcontroller to a host machine (our computer in this case) through the UART. To do this, we'll need to setup a UART peripheral and redefine the `printf()` function.

First of all, we are going to configure a new project (click [here][2] if you don't remember how to do it). Select your board from the menu and when you're asked if you want to configure the peripherals to their default mode click _yes_.

<!-- ![Image](/assets/images/blog/1/setup.png) -->

In this way _STM32CubeMX_ will automatically set the LED and the default UART interface for you. In my case it's the UART2.

Configure it to the following settings:
- baudrate: 115200 bps
- word length: 8 bits (including parity)
- parity: none
- stop bits: 1 bit

![Image](/assets/images/blog/1/uart.png)

Don't forget to set the _Toolchain/IDE_ field of the _Project Manager_ tab to _Makefile_.

Now that we are done with the configuration we can let _STM32CubeMX_ generate the code for us by clicking on the  _Generate Code_ button on the top right corner of the window. Let's have a look to it!

## printf statements and UART

You may notice in the first lines of the generated code that _STM32CubeMX_ has already declared a `UART_HandleTypeDef` object for us and also included its initialization function. A handle is a basic C structure which is used to store information about a peripheral. The initialization functions generated by the software will fill the fields of the handles with the chosen settings.

As you may know, the `printf()` function performs a `write()` to send messages to the standard output. This function is a system call and given the size of the message it will send the characters one by one to the output by calling  `putchar()` (click [here][3] if you want to know more about `write()`).

Microcontrollers such as STM32 don't come with an Operating System, so we need to find a _baremetal_ way to add system calls to the firmware. The easiest approach is to include [syscalls.c][4] to your project if it has not been created during the code generation phase. This file is a basic template and allow us to specify what we want to be done for each system call. In our case, we want the data to be transferred through the serial port when we execute a `printf()` call. In order to do this, we need to add `syscalls.c` to the makefile and make some changes.

First of all, we need to export the symbol associated with the UART handle.

```c
extern UART_HandleTypeDef huart2;
```

Next, comment out the previous definition of `__io_putchar()` and replace it by the following:

```c
__attribute__((weak)) int __io_putchar(int ch)
{
    HAL_StatusTypeDef status = HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, 0xFFFF);
    return (status == HAL_OK ? ch : 0);
}
```

Here we are explicitly redirecting the standard output to the UART2.

Then, move back to `main.c` and insert the following lines in the `while(1)` loop:

```c
while(1){
    printf("Hello world!\r\n");
    for(i = 0; i < 500000; i++){}       // wait
}
```

Add the standard library header file for input/output (needed for the printf) at the beginning of the file:

```c
#include <stdio.h>
```

Finally, compile and flash the binary as shown in the previous [tutorial][2].

Now we're ready to see if it works. Once you've plugged your board, run this command and find which device is associated with it:

```
$ ls /dev/tty.*
```

When you've found it, run `screen` specifying the name of the device and the baudrate.

```
$ screen /dev/tty.usbmodem14103 115200
```

Hey, nothing happened... we could have forgotten something. Let's find out what!

![Image](/assets/images/blog/1/nodata.png)

## stlink and troubleshooting

Before we getting into debugging you have to know what the _STLink_ is.

The _STLink_ is a piece of hardware embedded on your board which allows to program and debug the microcontroller. When you connect a _STM32_ to your computer via a USB connection, you are actually plugged to the _STLink_. It happens that this component can be used to send (TX) and receive (RX) data from a host machine through the UART.

I downloaded the _STM32L452RE-P_ [schematic][5] to investigate further and I have found something interesting.

As you can see in the image below, the _STLink_ embedded on the board is directly connected to the LPUART1. The LP stands for Low Power and it seems that this version is the default one of the board for the exchanges with the outside world.

![Image](/assets/images/blog/1/schematic.png)

Our previous configuration was sending the `printf()` messages to the UART2 which was not connected to anything (not so smart).

Time to fix this! Go back to your _STM32CubeMX_ project and replace the UART2 with the LPUART1 keeping the same settings and re-generate the code (make sure that the new changes have been added to the source files; re-add the deleted lines if needed).

![Image](/assets/images/blog/1/lpuart.png)

Don't forget to update `syscall.c`:

```c
extern UART_HandleTypeDef hlpuart1;
```

```c
__attribute__((weak)) int __io_putchar(int ch)
{
    HAL_StatusTypeDef status = HAL_UART_Transmit(&hlpuart1, (uint8_t *)&ch, 1, 0xFFFF);
    return (status == HAL_OK ? ch : 0);
}
```

Finally, compile and flash the board again.

## it works!

Now, if you run `screen` again, you should see some messages printed out to your console.

![Image](/assets/images/blog/1/result.png)

Isn't this great? :)

During embedded firmware development, especially on development kits, it is really important to keep in mind that the behaviour of your system strongly depends on the electrical characteristics of the circuit.

[Here][6] you can find the complete source code. I hope you enjoyed this article, stay tuned for the next one!

## references

Here are a bunch of links that helped me write this:

- [STM32 with macOS](https://github.com/glegrain/STM32-with-macOS)
- [how do i use the printf function on stm32?][1]
- [difference between write and printf][3]

[sh]: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0471m/pge1358787046598.html
[itm]: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337e/BABCCDFD.html
[uart]: https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter

[1]: https://electronics.stackexchange.com/questions/206113/how-do-i-use-the-printf-function-on-stm32
[2]: http://ayoubsabri.github.io/getting-started
[3]: https://stackoverflow.com/questions/21084218/difference-between-write-and-printf/21095842
[4]: https://gist.github.com/AyoubSabri/d66990b71c9dd4ba298c9ae4bfb88dd8
[5]: https://www.st.com/en/evaluation-tools/nucleo-l452re-p.html#resource
[6]: https://gist.github.com/AyoubSabri/d3afda7d95f122583fd3daf6fcd02ab3
